"""Execution.txt parser using Lark Transformer."""

from typing import Dict, Tuple, List
import pandas as pd
from lark import Transformer, v_args, Tree

from execution_grammar import pre_clean_execution, lark_parser

from collections import namedtuple

Group = namedtuple('Group', ['group_name', 'points', 'points_max', 'weighted_points', 'weighted_points_max'])
TransformedData = namedtuple('Parsed', ['timestamp', 'filename', 'grade', 'time_ms', 'groups'])


class ExecutionTransformer(Transformer):
    """
    Generated by AI assistant.

    Transforms parsed results from raw tokens into structured data.

    This class provides methods to handle individual tokens and transform them into appropriate
    data structures like timestamps, strings, floats, dictionaries, and tuples.
    It processes tokens from parsed results and organizes them into a structured format.
    The main purpose of  this class is to interpret parsed raw data and
    generate structured information suitable for further processing.
    """

    @v_args(inline=True)
    def timestamp(self, token) -> pd.Timestamp:
        return pd.to_datetime(token.value)

    @v_args(inline=True)
    def filename(self, token) -> str:
        return token.value.strip()

    @v_args(inline=True)
    def header(self, timestamp: pd.Timestamp, filename: str) -> Dict[str, object]:
        return {"timestamp": timestamp, "filename": filename}

    @v_args(inline=True)
    def group_name(self, token) -> str:
        return token.value.strip()

    @v_args(inline=True)
    def points(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def points_max(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def weighed_points(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def weighed_max(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def points_score(self, points: float, points_max: float) -> Tuple[float, float]:
        return points, points_max

    @v_args(inline=True)
    def points_weighed(self, weighed_points: float, weighed_max: float) -> Tuple[float, float]:
        return weighed_points, weighed_max

    @v_args(inline=True)
    def points_info(self, points_score: Tuple[float, float], points_weighed: Tuple[float, float]) -> Dict[str, float]:
        points, points_max = points_score
        weighted_points, weighted_max = points_weighed
        return {
            "points": points,
            "points_max": points_max,
            "weighted_points": weighted_points,
            "weighted_points_max": weighted_max,
        }

    def point_groups(self, children: list) -> Dict[str, List[Group]]:
        _ = self
        return {"groups": [
            Group(
                children[i],
                children[i + 1]["points"],
                children[i + 1]["points_max"],
                children[i + 1]["weighted_points"],
                children[i + 1]["weighted_points_max"],
            )
            for i in range(0, len(children), 2)
        ]}

    @v_args(inline=True)
    def grade_value(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def grade_section(self, _grade_marker, grade_value: float) -> Dict[str, float]:
        return {"grade": grade_value}

    @v_args(inline=True)
    def ms_time(self, token) -> float:
        return float(token.value)

    @v_args(inline=True)
    def time_section(self, _aeg, ms_time: float, _ms) -> Dict[str, float]:
        return {"time_ms": ms_time}

    def start(self, children: list) -> Dict[str, object]:
        _ = self
        final: Dict[str, object] = {}
        for child in children:
            if isinstance(child, dict):
                final.update(child)
        if "time_ms" not in final:
            final["time_ms"] = None
        return final


transformer = ExecutionTransformer()


def parse_execution(content: str) -> TransformedData:
    """
    Parses the execution.txt file content string into a namedtuple using a Lark parser
    and a transformer.
    The function processes the content through pre-cleaning, parsing, and transformation steps.
    If the transformation result is not of type dictionary, an error is raised.

    Args:
        content (str): The raw execution content to be parsed.

    Returns:
        TransformedData: A structured namedtuple representation of the parsed execution content.

        Example data:
            Parsed(
                timestamp=Timestamp('2024-11-21 20:44:05+0200', tz='UTC+02:00'),
                filename='Kodu5Test.java 4b8e4302fae95ecb',
                grade=76.3218,
                time_ms=11.8980476125,
                groups=[
                    Group(group_name='AVL operatsioonid', points=1.8620689655172413, points_max=2.0, weighted_points=13.5, weighted_points_max=14.5),
                    Group(group_name='Puude liitmine', points=1.0, points_max=1.0, weighted_points=6.5, weighted_points_max=6.5),
                    Group(group_name='Vabatahtlik lisa√ºlesanne', points=0.0, points_max=0.75, weighted_points=0.0, weighted_points_max=2.0)
                    ]
                )

    Raises:
        ValueError: If the transformation does not yield a dictionary.
    """
    content = pre_clean_execution(content)
    tree = lark_parser.parse(content)
    result_tree: Tree = transformer.transform(tree)

    if isinstance(result_tree, dict):
        return TransformedData(**result_tree)
    else:
        raise ValueError("Parsed execution file did not return a dictionary.")
